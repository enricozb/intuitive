pub mod hooks;

use std::collections::{HashMap, HashSet};

use lazy_static::lazy_static;
use parking_lot::Mutex;

use self::hooks::manager;
use crate::{
  components::Any as AnyComponent,
  element::Any as AnyElement,
  error::{Error, Result},
};
#[allow(unused)]
use crate::{components::Component, render};

lazy_static! {
  /// Maps a component ID to its component.
  static ref COMPONENTS: Mutex<HashMap<ComponentID, AnyComponent>> = Mutex::new(HashMap::new());

  /// Maps a component to the element it most recently returned after a render.
  static ref ELEMENTS: Mutex<HashMap<ComponentID, AnyElement>> = Mutex::new(HashMap::new());

  /// Maps a component to the components it renders directly..
  static ref DESCENDANTS: Mutex<HashMap<ComponentID, HashSet<ComponentID>>> = Mutex::new(HashMap::new());
}

/// A unique identifier associated with each instance of a [`Component`] used *across all* [`render!`] macros.
/// *This should rarely if ever be used manually*. These structs are automatically created when using the
/// [`render!`] macro. These fields are public because they must be referenced within the code generated by the
/// [`render!`] macro.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ComponentID {
  /// The name of the component.
  pub name: &'static str,
  /// The `key` parameter, if any, that was provided.
  pub key: Option<usize>,
  /// The file the component was used in.
  pub file: &'static str,
  /// An integer unique to each instance of a [`Component`] used across all [`render!`] macros.
  pub uid: usize,
}

/// Renders a component.
///
/// A [`ComponentID`] is required because it is used to track which hooks are used within the rendering of the
/// specific instance of a component.
pub fn render<C: Component + 'static + Send>(component_id: ComponentID, component: C) -> AnyElement {
  let component = AnyComponent::new(component);
  let element = render_impl(component_id, &component);

  COMPONENTS.lock().insert(component_id, component);
  ELEMENTS.lock().insert(component_id, element.clone());

  element
}

/// Renders a component, unmounting any elements if necessary.
fn render_impl(component_id: ComponentID, component: &AnyComponent) -> AnyElement {
  if let Some(parent_component_id) = manager::current_component_id() {
    if let Some(descendants) = DESCENDANTS.lock().get_mut(&parent_component_id) {
      descendants.insert(component_id);
    }
  }

  let old_descendants = DESCENDANTS.lock().remove(&component_id);
  DESCENDANTS.lock().insert(component_id, HashSet::new());

  // `component.render()` is wrapped in an `AnyElement::new` in order to ensure that every
  // component returns a unique container for its elements. This is so on rerenders, when
  // calling `AnyElement::swap`, we know we are affecting only a single component.
  let element = manager::with(component_id, || AnyElement::new(component.render()));

  if let Some(old_descendants) = old_descendants {
    let new_descendants = DESCENDANTS.lock().get(&component_id).expect("DESCENDANTS::get").clone();

    for unmounted_component_id in old_descendants.difference(&new_descendants) {
      unmount(*unmounted_component_id);
    }
  }

  element
}

/// Re-renders an already rendered component, specified by its [`ComponentID`].
///
/// # Errors
///
/// Will return `Err` if a component has not yet been rendered with the provided [`ComponentID`].
pub fn rerender(component_id: ComponentID) -> Result<()> {
  let component = COMPONENTS.lock().get(&component_id).cloned();
  if let Some(component) = component {
    let old_element = ELEMENTS.lock().get(&component_id).ok_or(Error::NoElement(component_id))?.clone();

    old_element.swap(&render_impl(component_id, &component));
  }

  Ok(())
}

/// Unmounts the component.
pub fn unmount(component_id: ComponentID) {
  COMPONENTS.lock().remove(&component_id);
  ELEMENTS.lock().remove(&component_id);

  let descendants = DESCENDANTS.lock().remove(&component_id);

  if let Some(descendants) = descendants {
    for descendant_component_id in descendants {
      unmount(descendant_component_id);
    }
  }

  manager::unmount(component_id);
}
